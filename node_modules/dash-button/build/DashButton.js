'use strict';

var _createClass = require('babel-runtime/helpers/create-class').default;

var _classCallCheck = require('babel-runtime/helpers/class-call-check').default;

var _asyncToGenerator = require('babel-runtime/helpers/async-to-generator').default;

var _Set = require('babel-runtime/core-js/set').default;

var _Array$from = require('babel-runtime/core-js/array/from').default;

var _Promise = require('babel-runtime/core-js/promise').default;

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default').default;

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _pcap = require('pcap');

var _pcap2 = _interopRequireDefault(_pcap);

var _ArpProbes = require('./ArpProbes');

var _ArpProbes2 = _interopRequireDefault(_ArpProbes);

var _MacAddresses = require('./MacAddresses');

var _MacAddresses2 = _interopRequireDefault(_MacAddresses);

var _NetworkInterfaces = require('./NetworkInterfaces');

var _NetworkInterfaces2 = _interopRequireDefault(_NetworkInterfaces);

let pcapSession;

function getPcapSession(interfaceName) {
  if (!pcapSession) {
    pcapSession = _ArpProbes2.default.createCaptureSession(interfaceName);
  } else {
    _assert2.default.equal(interfaceName, pcapSession.device_name, 'The existing pcap session must be listening on the specified interface');
  }
  return pcapSession;
}

let DashButton = (function () {
  function DashButton(macAddress) {
    let options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, DashButton);

    this._macAddress = macAddress;
    this._networkInterface = options.networkInterface || _NetworkInterfaces2.default.getDefault();
    this._packetListener = this._handlePacket.bind(this);
    this._dashListeners = new _Set();
    this._isResponding = false;
  }

  _createClass(DashButton, [{
    key: 'addListener',
    value: function addListener(listener) {
      var _this = this;

      if (!this._dashListeners.size) {
        let session = getPcapSession();
        session.addListener('packet', this._packetListener);
      }

      // We run the listeners with Promise.all, which rejects early as soon as
      // any of its promises are rejected. Since we want to wait for all of the
      // listeners to finish we need to catch any errors they may throw.
      let guardedListener = this._createGuardedListener(listener);
      this._dashListeners.add(guardedListener);

      return new Subscription(function () {
        _this._dashListeners.delete(guardedListener);
        if (!_this._dashListeners.size) {
          let session = getPcapSession();
          session.removeListener('packet', _this._packetListener);
          if (!session.listenerCount('packet')) {
            session.close();
          }
        }
      });
    }
  }, {
    key: '_createGuardedListener',
    value: function _createGuardedListener(listener) {
      return _asyncToGenerator(function* () {
        try {
          yield listener.apply(undefined, arguments);
        } catch (error) {
          return error;
        }
      });
    }
  }, {
    key: '_handlePacket',
    value: _asyncToGenerator(function* (rawPacket) {
      if (this._isResponding) {
        return;
      }

      let packet = _pcap2.default.decode(rawPacket);
      let macAddress = _MacAddresses2.default.getEthernetSource(packet);
      if (macAddress !== this._macAddress) {
        return;
      }

      this._isResponding = true;
      try {
        // The listeners are guarded so this should never throw, but wrap it in
        // try-catch to be defensive
        let listeners = _Array$from(this._dashListeners);
        yield _Promise.all(listeners.map(function (listener) {
          return listener(packet);
        }));
      } finally {
        this._isResponding = false;
      }
    })
  }]);

  return DashButton;
})();

exports.default = DashButton;

let Subscription = (function () {
  function Subscription(onRemove) {
    _classCallCheck(this, Subscription);

    this._remove = onRemove;
  }

  _createClass(Subscription, [{
    key: 'remove',
    value: function remove() {
      if (!this._remove) {
        return;
      }
      this._remove();
      delete this._remove;
    }
  }]);

  return Subscription;
})();

module.exports = exports.default;